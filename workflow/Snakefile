# script_dir = f"{os.path.dirname(os.path.abspath(__file__))}/../scripts"
import os
import pathlib

script_dir = "scripts"
import scripts.handle_config as handle_config
configfile: "config.yaml"

# report: "report/workflow.rst"

processed_config = handle_config.config_transform(config)

barcode_dir = f"data/sc_barcodes_v2"

sample_names = list(processed_config.keys())

# Add this at the top of the file, before any rules
wildcard_constraints:
    lane="[^_]*",  # Lane identifiers are not allowed to have underscores
    read="R[12]"


include: "rules/preprocess.smk"
include: "rules/sc_pipeline.smk"
include: "rules/align.smk"
include: "rules/handle_sam.smk"

def get_input(sample, lane, read):
    sample_config = processed_config[sample]['fastq']
    return sample_config[lane][0 if read == "R1" else 1]

def get_path_stem(path: str):
    # In case we get compressed files, they often have double extensions,
    # so we remove the final .gz in that case. Otherwise, only the final extension is removed
    uncompressed_path = path.removesuffix(".gz")
    stem = pathlib.Path(uncompressed_path).stem
    return stem

def expand_fastqc(sample):
    sample_config = processed_config[sample]
    template = "results/{sample}/qc/{filename}_fastqc.{format}"
    input_lanes = sample_config["fastq"].values()
    input_filestems = [get_path_stem(filename) for lane in input_lanes for filename in lane]
    return expand(
    template,
    sample=sample,
    filename=input_filestems,
    format=["html", "zip"],
    )

def get_fastqc_input(sample, filename):
    sample_config = processed_config[sample]
    for lane_files in sample_config["fastq"].values():
        for path in lane_files:
            if get_path_stem(path) == filename:
                return path
    raise ValueError("FastQC input file not found")

fastqc_output = [expand_fastqc(sample) for sample in sample_names]
gene_matrix_output = expand("results/{sample}/{sample}_gene_count_matrix.txt", sample=sample_names)
umi_table_output = expand("results/{sample}/{sample}_umi_count_table.txt", sample=sample_names)


knee_plot = expand("results/{sample}/{sample}_kneePlot.pdf", sample = sample_names)
histogram = expand("results/{sample}/{sample}_ReadsPerBC.pdf", sample = sample_names)

def intermediate_files():
    samples = processed_config.keys()
    templates = ["results/{sample}/{sample}_barcode_table.txt", "results/{sample}/{sample}_bc_frame.rds",
     "results/{sample}/{sample}_frequency_table.txt", "results/{sample}/{sample}_QF_R2_all_lanes.fastq"]
    files = [expand(template, sample=samples) for template in templates]
    return files


rule determine_bc_cutoff:
    input:
       fastqc_output,
       intermediate_files(),
    shell:
        """
        echo "In order to determine cutoff values, do the following:
Copy the frequency tables (results/(sample)/(sample)_frequency_table.txt)
to the computer of your choice.
In a graphical interactive R session, use read.table() with header=TRUE
to read the frequency table(s) one by one.
Run the Shiny app posDemux::interactive_bc_cutoff() on each of these frequency tables
and determine a suitable cutoff.
Finally, provide the determined values in config.yaml"
        """


rule all:
    input:
        fastqc_output,
        knee_plot,
        histogram,
        gene_matrix_output,
        umi_table_output
